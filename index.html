<!DOCTYPE html>
<html>

<head>
    <title>Hydrolang Use Case</title>
    <script type="module" onload="initHydrolang()" src="./hydrolang/hydro.js"></script>
</head>

<body>
    <script>
        function initHydrolang() {
            // configure hydrolang - this is optional, 
            // if user does not provide a config,
            // we'll just use the default values
            const config = {
                metricSystem: "SI",
                mapType: 'Google',
            }

            hydro1 = new Hydrolang();
            hydro1.setConfig(config);

            // An example usage
            console.log(hydro1.map.addLayer({}));


            /*** Basic use case for a bar chart **/

            temperatureData = [
                ['City', 'Temperature'],
                ['Iowa City', 78],
                ['Des Moines', 83],
                ['Waterloo', 54]
            ];

            hydro1.visualize.chart({
                chartType: "bar",
                data: temperatureData,
                divID: "barchartexample1"
            });


            /*** End of use case **/


            /*** Basic use case for statistics **/

            var ex = [12, 5, 2, 3, 4, 5, 6, 5, 4, 3, 2, 4, 5, 6, 3, 2, 3, 43, 2, 3, 2]
            //Identify and remove outliers
            var outliers = hydro1.analyze.stats.outliers(ex);
            var clean = hydro1.analyze.stats.outremove(ex);

            //Calculate metrics from clean array
            var minValue = hydro1.analyze.stats.min(clean);
            var maxValue = hydro1.analyze.stats.max(clean);
            var sumValue = hydro1.analyze.stats.sum(clean);
            var meanValue = hydro1.analyze.stats.mean(clean);
            var medianValue = hydro1.analyze.stats.median(clean);
            var stdValue = hydro1.analyze.stats.stddev(clean);
            var varValue = hydro1.analyze.stats.variance(clean);


            statparams = [
                ['Minimum value', minValue],
                ['Maximum', sumValue],
                ['Sum', meanValue],
                ['Mean', meanValue],
                ['Median', medianValue],
                ['Standard deviation', stdValue],
                ['Variance', varValue]
            ]

            ex1 = {
                graphdata: statparams,
                Columns: ['Metric', 'Value']
            };

            console.log(statparams);

            var statx = hydro1.analyze.stats.flatenise(ex1);


            hydro1.visualize.table({
                data: statx,
                divID: "statsexample",
                dataType: ['string', 'number'],
                options: {
                    x: "30%",
                    y: "30%",
                }
            });


            /*** End of use case **/

            /*** Basic use case for retrieving data **/


            //if token or key is required
            var tokennoa1 = "wOYszxFhCctvvmijQbDUaiVgNMmwFNQE";
            var tokennoa = "gNUkMgFHFSYVWyNoabuUfuVhCTJkRvRq";
            var keymet = "yTAaiogF40chlFKngC51f5yYpvGH67Zl";
            var keyaemet = "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJlcmF6Y2FyOEBhcXVhY2xvdWQubmV0IiwianRpIjoiN2JjMDg4MzQtYWRlYS00ZTZlLTgwZDItZjhhZWRhMDk1NzliIiwiaXNzIjoiQUVNRVQiLCJpYXQiOjE1OTIzNTA4MzUsInVzZXJJZCI6IjdiYzA4ODM0LWFkZWEtNGU2ZS04MGQyLWY4YWVkYTA5NTc5YiIsInJvbGUiOiIifQ.W_JR_t4EBSzgpWQye3Jj7vRF2g7s_Ex2w5YoEl7cIdc"
            var prox = "https://cors-anywhere.herokuapp.com/"

            //retrieve data from usgs (partially working)
            dataRetrievalParams1 = {
                "source": "usgs",
                "dataType": "instant-values",
                "arguments": {
                    "stateCd": "CA",
                    "format": "json"
                },
                "proxyurl": prox
            };

            //data retrieval from noaa (working)
            dataRetrievalParams2 = {
                "source": "noaa",
                "dataType": "prec-hourly",
                "type": "json",
                "arguments": {
                    "stationid": 'COOP:135199',
                    "units": "standard",
                    "startdate": "2012-02-01",
                    "enddate": "2013-01-01",
                    "metadata": false
                },
                "token": tokennoa1,
            };

            //data retrieval from meteostat	(working)		
            dataRetrievalParams3 = {
                "source": "meteostat",
                "dataType": "hourlydata-stations",
                "arguments": {
                    "station": "78720",
                    "start": "2019-06-01",
                    "end": "2019-06-05",
                },
                "x-api-key": keymet,
                "proxyurl": prox
            };

            //data retrieval from fema (working)	
            dataRetrievalParams4 = {
                "source": "fema",
                "dataType": "disaster-declarations",
                "arguments": {
                    "state": "CA",
                },
            };

            //data retrieval from aemet	(not working)	
            dataRetrievalParams5 = {
                "source": "aemet",
                "dataType": "daily-station",
                "arguments": {
                    "fechaIniStr": "2002",
                    "fechaFinStr": "2003",
                    "idema": "1351",
                },
                "api_key": keyaemet,
                "proxyurl": prox
            };

            //data retrieval from worldbank (not working)		
            dataRetrievalParams6 = {
                "source": "worldbank",
                "dataType": "monavgs-country",
                "arguments": {
                    "country": "BR",
                    "start": "2000",
                    "end": "2001",
                },
                "proxyurl": prox
            };

            function handleWaterData(data) {
                console.log(data);
                return data;
            }

            var hy1 = hydro1.data.retrieve(dataRetrievalParams3, handleWaterData);


            /*** End of use case **/


            /*** Basic use case for arithmetic mean
             * parameters: rainfall information for different stations as array
             * on a basin for the same rainfall event.  
             * Data is to be considered equal of equal time length for one rainfall event.
             **/

            raingages = Array(2);
            raingages[0] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
            raingages[1] = [2, 3, 5, 2, 3, 5, 6, 5, 4, 3]
            var arithprecs = hydro1.analyze.hydro.arithmetic(raingages);

            /*** End of use case **/


            /*** Use for thiessen polygons
             * parameters: raingage events for different stations on a basin.
             * also areas for each rainfall event.
             * Returns pondered precipitation, recommended for basins < 1000 km^2.
             **/

            thiessenprec = Array(4);
            thiessenareas = Array(4);
            for (var i = 0; i < thiessenprec.length; i++) {
                thiessenprec[i] = Array.from({
                    length: 40
                }, () => Math.floor(Math.random() * 20));
                thiessenareas[i] = Math.floor(Math.random() * 600);
            };

            thiessendata = {
                "rainfall": thiessenprec,
                "areas": thiessenareas,

            };

            var thiessenpol = hydro1.analyze.hydro.thiessen(thiessendata);

            /*** End of use case **/


            /*** Use of dimensionless unit hydrograph constructor.
             * options for distribution: gamma as of June 2020. Changes amount of volume
             * depending on the peak rate factor (PRF).
             * time of concentration, time step numhours: in hours 
             *  
             **/

            dimunithydrodata = {
                "distribution": {
                    "type": "gamma",
                    "PRF": 484,
                },
                "timestep": 0.20,
                "numhours": 5,
            };

            var dimunit = hydro1.analyze.hydro.dimunithydro(dimunithydrodata);

            /***End of example for dimensionless unit hydrograph constructor**/


            /*** Use of unit hydrograph constructor.
             * options for units: SI or Metric; if input something else, error will be thrown.
             * options for drainage area: square miles if SI or square kilometers.
             * time of concentration, time step numhours: in hours 
             *  
             **/

            unithydrodata = {
                "units": "si",
                "unithydro": dimunit,
                "drainagearea": 4.6,
                "tconcentration": 2.3,
            };

            var basinunit = hydro1.analyze.hydro.unithydrocons(unithydrodata);

            /***End of example for unit hydrograph constructor**/


            /*** Use of flood hydrograph constructor.
             * options for units: SI or Metric; if input something else, error will be thrown.
             * options for drainage area: square miles if SI or square kilometers.
             * time of concentration, time step numhours: in hours 
             * rainfall data: on the same time step as unit hydrograph (or 0.133Tc)
             **/

            var rainf = Array(2).fill(0).map(() => Array(21).fill(0));
            rainf[1] = [0, 0.1, 0.1, 0.1, 0.1, 0.1, 0.2, 0.3, 0.6, 0.5, 0.8, 0.9, 1, 1, 0.6, 0.2, 0.1, 0.1, 0.1, 0, 0];

            for (var h = 1; h < rainf[0].length; h++) {
                rainf[0][h] = rainf[0][h - 1] + 0.30;
            };

            floodhydrodata = {
                "units": "si",
                "rainfall": rainf,
                "unithydro": basinunit,
                "cn": 90,
                "stormduration": 6,
                "timestep": 0.30,
            };

            var flooding = hydro1.analyze.hydro.floodhydro(floodhydrodata);

            //flatenise the array using helper function.
            graphing = {
                graphdata: flooding,
                Columns: ['Duration', 'Discharge'],
            };

            var hydroexample = hydro1.analyze.stats.flatenise(graphing);
            console.log(hydroexample)

            //define configuration options accroding to Google Charts API.
            hydro1.visualize.chart({
                chartType: "line",
                data: hydroexample,
                divID: "smoothchart",
                options: {
                    title: "Hydrograph",
                    hAxis: {
                        minValue: 0
                    },
                    curveType: "function",
                    lineWidth: 3,
                    explorer: {
                        actions: ['dragToZoom', 'rightClickToReset']
                    },
                    legend: {
                        position: "bottom"
                    },
                }
            });

            /***End of example for flood hydrograph constructor**/


            /*** Use for bucket model data 
             * options for rainfall = timeseries array in mm per hour
             * options for evaporation = timeseries array in mm per hour
             * options for baseflow = value in m3 per hour if know, else leave with 1 m3 per hour;
             * options for landuse types= percentage value.
             * options for infiltration capacity = percentage value.
             * options for Landuse = array with percentages for agriculture, rock, grassland, forest, moorland
             **/

            rainfallData = [1, 2, 3, 1, 2, 1, 2, 3, 2, 1, 2, 3, 4];
            evapodata = [0.1, 0.2, 0.3, 0.2, 0.3, 0.4, 0.5, 0.8, 0.9, 0.4, 0.25, 0.30, 0.57];
            baseflow = 10;
            Landuse = [0.25, 0.10, 0.30, 0.15, 0.2];
            infiltation = 0.3;
            dataBucketModel = {
                "rainfall": rainfallData,
                "baseflow": baseflow,
                "evaporation": {
                    "dataType": "timeseries",
                    "data": evapodata
                },
                "landuse": {
                    "agriculture": Landuse[0],
                    "bare rock": Landuse[1],
                    "grassland": Landuse[2],
                    "forest": Landuse[3],
                    "moorland": Landuse[4]
                },
                "infiltration": infiltation
            };

            var bucket = hydro1.analyze.hydro.bucketmodel(dataBucketModel);

            /***End of example for bucket model**/

        }
    </script>
    <p id="infobox">This website uses HydroLang!</p>
    <div id="statsexample"></div>
    <div></div>
    <div id="barchartexample1"></div>
    <div></div>
    <div id="smoothchart"></div>
    <div></div>
</body>

</html>